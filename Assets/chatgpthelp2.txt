
ÅŸimdi istenen â€œ**duvara tÄ±rmanma**â€ Ã¶zelliÄŸini ekliyorum ve **tam PlayerState**â€™i gÃ¼ncelliyorum. AÅŸaÄŸÄ±da SADECE ek/patchâ€™ler var (Ã¶nceki kodun Ã¼stÃ¼ne koy).

---

# ğŸ§± Yeni Layer ve Kavram

* **Climbable** *(Trigger layer)*: DuvarÄ±n **katÄ±** Ground colliderâ€™Ä±na ek olarak, kenara **child Trigger** ekle (`Layer=Climbable`, `IsTrigger=on`).

  > BÃ¶ylece oyuncu duvardan **geÃ§mez**, ama â€œtÄ±rmanÄ±labilirâ€ bilgisini triggerâ€™dan alÄ±r.

---

# ğŸ§  PlayerState â€” GÃ¼ncel Tam Liste (HFSM)

```
Grounded
 â”œâ”€ Idle
 â””â”€ Run
Airborne
 â”œâ”€ JumpRise
 â””â”€ JumpFall
WallSlide
WallClimb        <-- YENÄ°
LedgeHang
Climb (Ladder/Rope)
```

**KÄ±sa Fazlar:** `WallJump`, `LedgeClimb`, `DropThrough`
**Ã–ncelik:** `LedgeHang > WallClimb > WallSlide > Climb(Ladder) > Airborne > Grounded`

**GiriÅŸ/Ã‡Ä±kÄ±ÅŸ (Ã¶zet):**

* **WallClimb (yeni)**

  * *GiriÅŸ:* `wallLeft/right && onClimbable(side) && (|MoveY|>0.1f veya MoveX duvar yÃ¶nÃ¼ne)`
  * *DavranÄ±ÅŸ:* Gravity **off**, `velY = MoveY * wallClimbSpeed`, yatay hareket kilit.
  * *Ã‡Ä±kÄ±ÅŸ:* Climbable biter â†’ `WallSlide` (duvar varsa) ya da `JumpFall`. `Jump` â†’ `JumpRise` (duvardan ayrÄ±larak).

---

# ğŸ”§ Kod Ekleri / DeÄŸiÅŸiklikler

## 1) Yeni Config: `WallClimbConfig.cs`

```csharp
using UnityEngine;

[CreateAssetMenu(menuName = "Configs/WallClimbConfig")]
public class WallClimbConfig : ScriptableObject
{
    [Min(0f)] public float climbSpeed = 3.5f;    // dikey hÄ±z
    [Range(0f, 1f)] public float stickFriction = 0.15f; // yatay kaymayÄ± bastÄ±rma
    public float enterMinMoveY = 0.1f;           // tetiÄŸe girmek iÃ§in min Up/Down
}
```

## 2) `Sensors2D.cs` â€” **Climbable** algÄ±sÄ± eklendi (PATCH)

```csharp
// ... class Sensors2D iÃ§inde:
public LayerMask climbableMask;   // << YENÄ°

public bool onClimbableLeft  { get; private set; } // << YENÄ°
public bool onClimbableRight { get; private set; } // << YENÄ°
public bool onClimbableAny   => onClimbableLeft || onClimbableRight; // << YENÄ°

public void Sample()
{
    // ... mevcut yerler aynÄ±

    // --- Climbable (trigger) â€” sol/saÄŸ duvar kÃ¶ÅŸelerinde kÃ¼Ã§Ã¼k kapsÃ¼lle kontrol
    onClimbableLeft  = Physics2D.OverlapCircle(wallL.position, 0.12f, climbableMask);
    onClimbableRight = Physics2D.OverlapCircle(wallR.position, 0.12f, climbableMask);

    // ... kalanlar aynÄ± (Interactable vs.)
}
```

> **Inspector:** `climbableMask = Climbable` layerâ€™Ä±nÄ± iÃ§erir.

## 3) Motor: `LocomotionMotor2D.cs` â€” **WallClimb** destek (PATCH)

```csharp
// class alanlarÄ±na ekle:
public WallClimbConfig wallClimbCfg;   // << YENÄ°

bool wallClimbing;                      // << YENÄ°
int  wallClimbDir;                      // -1 sol, +1 saÄŸ  (YENÄ°)
float wallClimbV;                       // hedef dikey hÄ±z (YENÄ°)

// Requests (yeni):
public void RequestWallClimb(int dir, float vSpeed)
{
    wallClimbing = true;
    wallClimbDir = Mathf.Clamp(dir, -1, 1);
    wallClimbV   = vSpeed;
    rb.gravityScale = 0f;
    // yÃ¼zeye yapÄ±ÅŸmayÄ± artÄ±rmak iÃ§in hafif iÃ§e doÄŸru Ã§ek
    var v = rb.velocity; v.x = Mathf.Lerp(v.x, 0f, wallClimbCfg ? wallClimbCfg.stickFriction : 0.15f);
    rb.velocity = v;
}

public void StopWallClimbRestoreGravity()
{
    wallClimbing = false;
    rb.gravityScale = movement ? movement.gravityScale : 3.5f;
}

// PhysicsStep iÃ§inde, hanging/climbing kontrollerinden sonra, CLIMB LADDER bloÄŸundan Ã¶nce:
if (wallClimbing)
{
    // yatay sabit, dikey kontrol: MoveY motor dÄ±ÅŸÄ±ndan setlenir (controller hesaplar)
    rb.velocity = new Vector2(0f, wallClimbV);
    return;
}

// PhysicsStep sonunda, frame-lik istekleri temizlerken:
wallSlideRequested = false;
// wallClimbing burada TEMÄ°ZLENMEZ; kontrolcÃ¼ kapatana kadar devam eder
```

## 4) Yeni denetleyici: `WallClimbController.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class WallClimbController : MonoBehaviour
{
    public WallClimbConfig cfg;

    InputAdapter input;
    Sensors2D s;
    LocomotionMotor2D motor;
    PlayerStateMachine fsm;

    void Awake()
    {
        input = GetComponent<InputAdapter>();
        s     = GetComponent<Sensors2D>();
        motor = GetComponent<LocomotionMotor2D>();
        fsm   = GetComponent<PlayerStateMachine>();
    }

    public void Tick(float dt)
    {
        // girmek iÃ§in: duvar + climbable + kullanÄ±cÄ± isteÄŸi (Up/Down veya duvar yÃ¶nÃ¼ne itme)
        int dir = 0;
        bool want = Mathf.Abs(input.MoveY) > cfg.enterMinMoveY;
        if (s.wallLeft && s.onClimbableLeft && (want || input.MoveX < -0.1f))  dir = -1;
        if (s.wallRight && s.onClimbableRight && (want || input.MoveX >  0.1f)) dir = +1;

        if (dir != 0)
        {
            float v = input.MoveY * cfg.climbSpeed; // yukarÄ±/asaÄŸÄ±
            motor.RequestWallClimb(dir, v);
            fsm.RequestTransition(PlayerStateMachine.LocoState.WallClimb, "WallClimb");
        }

        // WallClimb aktifken kontroller
        if (fsm.Current == PlayerStateMachine.LocoState.WallClimb)
        {
            // dikey hÄ±z gÃ¼ncelle
            motor.RequestWallClimb(dir != 0 ? dir : (s.wallLeft ? -1 : (s.wallRight ? 1 : 0)),
                                   input.MoveY * cfg.climbSpeed);

            // ayrÄ±lma koÅŸullarÄ±
            if (!(s.onClimbableAny && (s.wallLeft || s.wallRight)))
            {
                motor.StopWallClimbRestoreGravity();
                // duvar var ama climbable yoksa WallSlide'a dÃ¼ÅŸ, deÄŸilse JumpFall
                if (!s.isGrounded && (s.wallLeft || s.wallRight))
                    fsm.RequestTransition(PlayerStateMachine.LocoState.WallSlide, "ExitWallClimb->Slide");
                else
                    fsm.RequestTransition(PlayerStateMachine.LocoState.JumpFall, "ExitWallClimb");
            }
            else if (input.JumpPressed)
            {
                motor.StopWallClimbRestoreGravity();
                fsm.RequestTransition(PlayerStateMachine.LocoState.JumpRise, "WallClimbJump");
            }
        }
    }
}
```

## 5) `AbilityController.cs` â€” Ã–ncelik sÄ±rasÄ±na **WallClimb** ekle (PATCH)

```csharp
// Awake() iÃ§inde:
var wallClimb = GetComponent<WallClimbController>();

// Tick() iÃ§inde, Ã¶ncelik sÄ±rasÄ±:
ledge?.Tick(dt);
wallClimb?.Tick(dt);   // << YENÄ° â€” Ledgeâ€™den sonra, WallSlideâ€™dan Ã¶nce
wall?.Tick(dt);
climb?.Tick(dt);
jump?.Tick(dt);
interact?.Tick(dt);
```

## 6) `PlayerStateMachine.cs` â€” state enumâ€™una ek (PATCH)

```csharp
public enum LocoState { Idle, Run, JumpRise, JumpFall, WallSlide, WallClimb, LedgeHang, Climb }
```

## 7) `AnimationStateSync.cs` â€” yeni bool (PATCH)

```csharp
// LateSync():
anim.SetBool("WallClimbing", fsm.Current == PlayerStateMachine.LocoState.WallClimb);
```

> Animatorâ€™a yeni bir bool param: **`WallClimbing`** ekleyebilirsin (opsiyonel).

## 8) `PlayerOrchestrator.cs` â€” hiÃ§bir deÄŸiÅŸiklik gerekmez

(Referans olarak `WallClimbController` bileÅŸeni eklenecek; Orchestrator generic Ã§alÄ±ÅŸÄ±yor.)

---

# ğŸ“„ README GÃœNCELLEME (kÄ±sa)

* **Yeni Layer:** `Climbable` (Trigger).

  * Duvar prefabâ€™Ä±nda **child** oluÅŸtur â†’ `BoxCollider2D (IsTrigger=on, Layer=Climbable)` â†’ tÄ±rmanÄ±labilir ÅŸerit.
* **Sensors2D maskâ€™larÄ±:** `climbableMask = Climbable`.
* **Yeni ScriptableObject:** `WallClimbConfig` oluÅŸtur ve `WallClimbController` ile `LocomotionMotor2D`â€™ye ata.
* **Player bileÅŸenleri:** `WallClimbController` ekle (cfg baÄŸla).
* **Animator (ops):** Bool **WallClimbing** paramÄ± ekle; wall-climb animine baÄŸla.
* **Ã–ncelik:** Ledge > **WallClimb** > WallSlide > Ladder > Jump > Ground/Air.

---

hepsi bu. bu yamalarla oyuncu **duvara tÄ±rmanabilir** (Up/Down ile, yalnÄ±z â€œClimbableâ€ triggerâ€™Ä± olan duvarlarda), **state makinen** gÃ¼ncel ve animasyon bayraklarÄ± hazÄ±r.
