tamam—tüm kodları temizledim, “solid vs trigger” ayrımını netleştirdim (isGround, isWall, isLedge, onLadder…), **ledge marker** ve **ladder trigger** ekledim; sonra da en alta tek seferde kurulum için **SETUP: README.md** bıraktım. hepsi “Player” odaklıdır.

---

# 📁 ScriptableObject Configs

## `MovementConfig.cs`

```csharp
using UnityEngine;

[CreateAssetMenu(menuName = "Configs/MovementConfig")]
public class MovementConfig : ScriptableObject
{
    [Header("Run / Air Control")]
    [Min(0.1f)] public float maxRunSpeed = 6f;
    [Tooltip("Seconds to reach target speed on ground")]
    [Min(0.01f)] public float accelTime = 0.12f;
    [Tooltip("Seconds to stop on ground")]
    [Min(0.01f)] public float decelTime = 0.12f;
    [Range(0f, 1f)] public float airControl = 0.55f;

    [Header("Gravity")]
    public float gravityScale = 3.5f;

    [Header("Wall Slide")]
    [Min(0f)] public float wallSlideMaxFall = 2.5f;
}
```

## `JumpConfig.cs`

```csharp
using UnityEngine;

[CreateAssetMenu(menuName = "Configs/JumpConfig")]
public class JumpConfig : ScriptableObject
{
    [Header("Heights (Unity units)")]
    public float shortJumpHeight = 1.25f;
    public float fullJumpHeight  = 2.6f;

    [Header("Timing (ms)")]
    public float jumpHoldMs = 180f; // variable jump window
    public float coyoteMs   = 150f; // after leaving ground
    public float bufferMs   = 150f; // before landing

    [Header("Cut / Ceiling")]
    public bool ceilingCancel = true;
    [Range(0.1f, 1f)] public float cutMultiplier = 0.55f;
}
```

## `WallConfig.cs`

```csharp
using UnityEngine;

[CreateAssetMenu(menuName = "Configs/WallConfig")]
public class WallConfig : ScriptableObject
{
    [Min(0.01f)] public float wallCheckDist = 0.2f;
    [Range(10f, 85f)] public float wallJumpAngle = 55f;
    [Min(0.1f)] public float wallJumpImpulse = 10f;
}
```

## `LedgeConfig.cs`

```csharp
using UnityEngine;

[CreateAssetMenu(menuName = "Configs/LedgeConfig")]
public class LedgeConfig : ScriptableObject
{
    public float probeRadius = 0.12f;
    public float snapLerp = 0.85f;
    public Vector2 defaultClimbShift = new Vector2(0.5f, 0.9f);
    public float hangTimeoutMs = 0f; // 0 = unlimited
}
```

## `ClimbConfig.cs`

```csharp
using UnityEngine;

[CreateAssetMenu(menuName = "Configs/ClimbConfig")]
public class ClimbConfig : ScriptableObject
{
    [Min(0f)] public float climbSpeed = 4f;
    public float enterTolerance = 0.1f;
    public float exitThreshold  = 0.15f;
}
```

---

# 🧩 Trigger Yardımcıları (dünya işaretleri)

## `LedgeMarker.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class LedgeMarker : MonoBehaviour
{
    [Tooltip("Hang pivot world offset relative to this trigger center")]
    public Vector2 hangOffset = new Vector2(0f, -0.05f);
    [Tooltip("Climb up shift (local), x yönü kenar yönüne göre ± uygulanır")]
    public Vector2 climbUpShift = new Vector2(0.5f, 0.9f);
    [Tooltip("Which side player should face when hanging: -1 left, +1 right, 0 auto")]
    public int preferFacing = 0;

    public Vector2 WorldHangPoint => (Vector2)transform.position + hangOffset;
}
```

## `LadderVolume.cs` *(opsiyonel param)*

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class LadderVolume : MonoBehaviour
{
    public float overrideClimbSpeed = -1f; // <0 means use config
}
```

## `Interactable.cs` *(örnek marker, basit)*

```csharp
using UnityEngine;

public class Interactable : MonoBehaviour
{
    public string prompt = "Press [E]";
    public void Activate() { /* kapı/lever mantığını burada yazarsın */ }
}
```

---

# 🎮 Input & Sensors

## `InputAdapter.cs`

```csharp
using UnityEngine;
using UnityEngine.InputSystem;

[DisallowMultipleComponent]
public class InputAdapter : MonoBehaviour
{
    [Header("Input Actions")]
    public InputActionReference move;     // Vector2
    public InputActionReference jump;     // Button
    public InputActionReference interact; // Button (optional)

    public float MoveX { get; private set; }
    public float MoveY { get; private set; }
    public bool  JumpHeld { get; private set; }
    public bool  JumpPressed { get; private set; }
    public bool  DownHeld => MoveY < -0.5f;
    public bool  InteractPressed { get; private set; }

    void OnEnable()
    {
        move?.action?.Enable();
        jump?.action?.Enable();
        interact?.action?.Enable();
    }
    void OnDisable()
    {
        move?.action?.Disable();
        jump?.action?.Disable();
        interact?.action?.Disable();
    }

    public void Collect()
    {
        Vector2 mv = move ? move.action.ReadValue<Vector2>() : Vector2.zero;
        MoveX = Mathf.Clamp(mv.x, -1f, 1f);
        MoveY = Mathf.Clamp(mv.y, -1f, 1f);
        JumpHeld = jump && jump.action.IsPressed();
        JumpPressed = jump && jump.action.WasPressedThisFrame();
        InteractPressed = interact && interact.action.WasPressedThisFrame();
    }

    public void ClearFrameEdges()
    {
        JumpPressed = false;
        InteractPressed = false;
    }
}
```

## `Sensors2D.cs`  *(solid vs trigger ayrımı; ledge/ladder/interact destekli)*

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class Sensors2D : MonoBehaviour
{
    [Header("Transforms")]
    public Transform feet;
    public Transform head;
    public Transform wallL;
    public Transform wallR;
    public Transform ledgeProbe; // göğüs/baş hizası, ileri uca yakın

    [Header("Layer Masks")]
    public LayerMask solidMask;       // Ground | OneWay | MovingPlatform (solid)
    public LayerMask oneWayMask;      // sadece OneWay
    public LayerMask wallMask;        // genelde Ground ile aynı
    public LayerMask ladderMask;      // Ladder (trigger)
    public LayerMask ledgeMask;       // Ledge (trigger)
    public LayerMask interactMask;    // Interactable (trigger)

    [Header("Sizes / Distances")]
    public float feetRadius  = 0.12f;
    public float headRadius  = 0.12f;
    public float wallDist    = 0.18f;
    public float interactRad = 0.6f;

    // OUTPUTS
    public bool isGrounded { get; private set; }
    public bool justLanded { get; private set; }
    public bool headBlocked { get; private set; }
    public bool wallLeft { get; private set; }
    public bool wallRight { get; private set; }
    public bool onOneWay { get; private set; }
    public bool onLadder { get; private set; }
    public bool isLedge  { get; private set; }
    public LedgeMarker activeLedge { get; private set; }
    public Interactable nearestInteractable { get; private set; }

    bool prevGrounded;

    public void Sample()
    {
        // Ground / OneWay (solid)
        isGrounded = Physics2D.OverlapCircle(feet.position, feetRadius, solidMask);
        onOneWay   = Physics2D.OverlapCircle(feet.position, feetRadius, oneWayMask);
        justLanded = !prevGrounded && isGrounded;
        prevGrounded = isGrounded;

        // Head (solid)
        headBlocked = Physics2D.OverlapCircle(head.position, headRadius, solidMask);

        // Walls (solid ray)
        wallLeft  = Physics2D.Raycast(wallL.position, Vector2.left,  wallDist, wallMask);
        wallRight = Physics2D.Raycast(wallR.position, Vector2.right, wallDist, wallMask);

        // Ladder (trigger)
        onLadder = Physics2D.OverlapCircle(transform.position, 0.16f, ladderMask);

        // Ledge (trigger first, then geometric fallback)
        activeLedge = null;
        isLedge = false;
        var hitL = Physics2D.OverlapCircle(ledgeProbe.position, 0.12f, ledgeMask);
        if (hitL)
        {
            activeLedge = hitL.GetComponent<LedgeMarker>();
            if (!activeLedge) activeLedge = hitL.transform.GetComponentInParent<LedgeMarker>();
        }
        if (activeLedge != null)
        {
            isLedge = true;
        }
        else if (!isGrounded)
        {
            // Fallback: üst boş - alt dolu kenar tespiti (dayanıklı olmayabilir)
            bool spaceAtHead = !Physics2D.OverlapCircle(head.position, headRadius, solidMask);
            bool groundBelow = Physics2D.Raycast(ledgeProbe.position, Vector2.down, 0.4f, solidMask);
            isLedge = spaceAtHead && groundBelow;
        }

        // Interactable (trigger)
        nearestInteractable = null;
        var colliders = Physics2D.OverlapCircleAll(transform.position, interactRad, interactMask);
        float best = float.MaxValue;
        foreach (var c in colliders)
        {
            var i = c.GetComponent<Interactable>() ?? c.GetComponentInParent<Interactable>();
            if (!i) continue;
            float d = Vector2.SqrMagnitude((Vector2)c.transform.position - (Vector2)transform.position);
            if (d < best) { best = d; nearestInteractable = i; }
        }
    }
}
```

---

# 🧠 State & Orchestration

## `PlayerStateMachine.cs`

```csharp
using UnityEngine;
using System;

[DisallowMultipleComponent]
public class PlayerStateMachine : MonoBehaviour
{
    public enum LocoState { Idle, Run, JumpRise, JumpFall, WallSlide, LedgeHang, Climb }
    public enum PhaseState { None, WallJump, LedgeClimb, DropThrough }

    public LocoState Current { get; private set; } = LocoState.Idle;
    public PhaseState Phase { get; private set; } = PhaseState.None;

    public event Action<LocoState, LocoState> OnLocoChanged;
    public event Action<PhaseState> OnPhaseTriggered;

    public void ForceSet(LocoState s)
    {
        if (s == Current) return;
        var old = Current;
        Current = s;
        OnLocoChanged?.Invoke(old, s);
    }

    public bool RequestTransition(LocoState target, string reason = "")
    {
        if (target == Current) return false;
        ForceSet(target);
        return true;
    }

    public void TriggerPhase(PhaseState p)
    {
        Phase = p;
        OnPhaseTriggered?.Invoke(p);
        Phase = PhaseState.None;
    }
}
```

## `PlayerOrchestrator.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class PlayerOrchestrator : MonoBehaviour
{
    InputAdapter input;
    Sensors2D sensors;
    AbilityController abilities;
    LocomotionMotor2D motor;
    AnimationStateSync animSync;

    void Awake()
    {
        input    = GetComponent<InputAdapter>();
        sensors  = GetComponent<Sensors2D>();
        abilities= GetComponent<AbilityController>();
        motor    = GetComponent<LocomotionMotor2D>();
        animSync = GetComponent<AnimationStateSync>();
    }

    void Update()
    {
        input?.Collect();
        sensors?.Sample();
        abilities?.Tick(Time.deltaTime);
        input?.ClearFrameEdges();
    }

    void FixedUpdate() => motor?.PhysicsStep(Time.fixedDeltaTime);
    void LateUpdate()  => animSync?.LateSync();
}
```

---

# ⚙️ Motor (tek fizik yazarı)

## `LocomotionMotor2D.cs`

```csharp
using UnityEngine;

[RequireComponent(typeof(Rigidbody2D))]
[DisallowMultipleComponent]
public class LocomotionMotor2D : MonoBehaviour
{
    public MovementConfig movement;
    public JumpConfig jumpCfg;
    public WallConfig wallCfg;
    public LedgeConfig ledgeCfg;
    public ClimbConfig climbCfg;

    Rigidbody2D rb;
    Sensors2D sensors;
    PlayerStateMachine fsm;

    // Intent/state
    float desiredX;
    float jumpHoldTimerMs;
    bool  allowCutJump;
    bool  wallSlideRequested;
    int   wallDir; // -1 left, +1 right
    bool  hanging;
    Vector2 hangPoint;
    bool  climbing;
    float climbVSpeed;

    public float velocityX => rb.velocity.x;
    public float velocityY => rb.velocity.y;
    public int facingSign { get; private set; } = 1;

    void Awake()
    {
        rb = GetComponent<Rigidbody2D>();
        sensors = GetComponent<Sensors2D>();
        fsm = GetComponent<PlayerStateMachine>();
        rb.interpolation = RigidbodyInterpolation2D.Interpolate;
        rb.gravityScale = movement ? movement.gravityScale : 3.5f;
    }

    // --------- Requests from controllers ----------
    public void RequestHorizontalIntent(float moveX)
    {
        desiredX = Mathf.Clamp(moveX, -1f, 1f);
        if (Mathf.Abs(moveX) > 0.01f) facingSign = moveX > 0 ? 1 : -1;
    }

    public void RequestJump(float upVelocity, bool cutEnabled)
    {
        var v = rb.velocity; v.y = upVelocity; rb.velocity = v;
        jumpHoldTimerMs = jumpCfg ? jumpCfg.jumpHoldMs : 180f;
        allowCutJump = cutEnabled;
        fsm.TriggerPhase(PlayerStateMachine.PhaseState.None);
    }

    public void RequestWallSlide(int dir)
    {
        wallSlideRequested = true;
        wallDir = Mathf.Clamp(dir, -1, 1);
    }

    public void RequestWallJump(Vector2 impulse)
    {
        rb.velocity = impulse;
        wallSlideRequested = false;
        fsm.TriggerPhase(PlayerStateMachine.PhaseState.WallJump);
    }

    public void RequestLedgeHang(Vector2 snapPoint, int facing = 0)
    {
        hanging = true;
        hangPoint = snapPoint;
        rb.velocity = Vector2.zero;
        rb.gravityScale = 0f;
        if (facing != 0) facingSign = facing;
    }

    public void RequestLedgeClimb(int dirSign, Vector2 climbShift)
    {
        if (!hanging) return;
        rb.position = rb.position + climbShift * new Vector2(Mathf.Sign(dirSign), 1f);
        hanging = false;
        rb.gravityScale = movement.gravityScale;
        fsm.TriggerPhase(PlayerStateMachine.PhaseState.LedgeClimb);
    }

    public void RequestClimb(float verticalSpeed)
    {
        climbing = true;
        climbVSpeed = verticalSpeed;
        rb.gravityScale = 0f;
    }

    public void RequestStopClimbRestoreGravity()
    {
        climbing = false;
        rb.gravityScale = movement.gravityScale;
    }
    // ----------------------------------------------

    public void PhysicsStep(float fixedDt)
    {
        // Ledge hang → pozisyonu kilitle
        if (hanging)
        {
            rb.velocity = Vector2.zero;
            rb.position = Vector2.Lerp(rb.position, hangPoint, ledgeCfg ? ledgeCfg.snapLerp : 0.85f);
            return;
        }

        // Tırmanış
        if (climbing)
        {
            rb.velocity = new Vector2(0f, climbVSpeed);
            return;
        }

        // Yatay hız ayarı (smoothing)
        float target = desiredX * (movement ? movement.maxRunSpeed : 6f);
        float accelRate = (Mathf.Abs(target) > 0.01f)
            ? (1f / Mathf.Max(0.01f, movement ? movement.accelTime : 0.12f))
            : (1f / Mathf.Max(0.01f, movement ? movement.decelTime : 0.12f));
        float ctrl = sensors.isGrounded ? 1f : (movement ? movement.airControl : 0.5f);
        float maxStep = (movement ? movement.maxRunSpeed : 6f) * accelRate * ctrl * fixedDt;
        float vx = Mathf.MoveTowards(rb.velocity.x, target, maxStep);

        // Variable jump hold / cut
        if (jumpHoldTimerMs > 0f)
            jumpHoldTimerMs -= fixedDt * 1000f;
        else if (allowCutJump && rb.velocity.y > 0f)
        {
            rb.velocity = new Vector2(vx, rb.velocity.y * (jumpCfg ? jumpCfg.cutMultiplier : 0.55f));
            allowCutJump = false;
        }
        if (sensors.headBlocked && rb.velocity.y > 0f && (jumpCfg ? jumpCfg.ceilingCancel : true))
        {
            rb.velocity = new Vector2(vx, 0f);
            allowCutJump = false;
            return;
        }

        // Wall slide düşüş hızı sınırı
        float vy = rb.velocity.y;
        if (wallSlideRequested && !sensors.isGrounded)
        {
            vy = Mathf.Max(vy, -(movement ? movement.wallSlideMaxFall : 2.5f));
        }

        rb.velocity = new Vector2(vx, vy);
        wallSlideRequested = false; // one-frame
    }
}
```

---

# 🧠 Yetenek & Davranış “işçileri”

## `JumpController.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class JumpController : MonoBehaviour
{
    public JumpConfig jumpCfg;
    public MovementConfig moveCfg;

    InputAdapter input;
    Sensors2D sensors;
    LocomotionMotor2D motor;
    PlayerStateMachine fsm;

    float coyoteMsLeft;
    float bufferMsLeft;

    void Awake()
    {
        input = GetComponent<InputAdapter>();
        sensors = GetComponent<Sensors2D>();
        motor = GetComponent<LocomotionMotor2D>();
        fsm = GetComponent<PlayerStateMachine>();
    }

    public void Tick(float dt)
    {
        // coyote
        if (sensors.isGrounded) coyoteMsLeft = jumpCfg.coyoteMs;
        else coyoteMsLeft = Mathf.Max(0f, coyoteMsLeft - dt * 1000f);

        // buffer
        if (input.JumpPressed) bufferMsLeft = jumpCfg.bufferMs;
        else bufferMsLeft = Mathf.Max(0f, bufferMsLeft - dt * 1000f);

        // OneWay drop (Effector ile çalışır)
        if (input.DownHeld && input.JumpPressed && sensors.onOneWay)
        {
            fsm.TriggerPhase(PlayerStateMachine.PhaseState.DropThrough);
            return;
        }

        // Jump apply
        bool canJump = sensors.isGrounded || coyoteMsLeft > 0f;
        if (bufferMsLeft > 0f && canJump)
        {
            float g = Mathf.Abs(Physics2D.gravity.y * (moveCfg ? moveCfg.gravityScale : 3.5f));
            float vShort = Mathf.Sqrt(2f * g * jumpCfg.shortJumpHeight);
            float vFull  = Mathf.Sqrt(2f * g * jumpCfg.fullJumpHeight);
            float v = input.JumpHeld ? vFull : vShort;

            motor.RequestJump(v, cutEnabled: true);
            bufferMsLeft = 0f;
            coyoteMsLeft = 0f;
            fsm.RequestTransition(PlayerStateMachine.LocoState.JumpRise, "Jump");
        }
    }
}
```

## `WallMovement.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class WallMovement : MonoBehaviour
{
    public WallConfig wallCfg;
    InputAdapter input;
    Sensors2D sensors;
    LocomotionMotor2D motor;
    PlayerStateMachine fsm;

    void Awake()
    {
        input  = GetComponent<InputAdapter>();
        sensors= GetComponent<Sensors2D>();
        motor  = GetComponent<LocomotionMotor2D>();
        fsm    = GetComponent<PlayerStateMachine>();
    }

    public void Tick(float dt)
    {
        if (sensors.isGrounded) return;

        int dir = 0;
        if (sensors.wallLeft  && input.MoveX < -0.1f) dir = -1;
        if (sensors.wallRight && input.MoveX > +0.1f) dir = +1;

        if (dir != 0)
        {
            motor.RequestWallSlide(dir);
            fsm.RequestTransition(PlayerStateMachine.LocoState.WallSlide, "WallSlide");

            if (input.JumpPressed)
            {
                float a = Mathf.Deg2Rad * wallCfg.wallJumpAngle;
                Vector2 outDir = new Vector2(-dir * Mathf.Cos(a), Mathf.Sin(a)).normalized;
                motor.RequestWallJump(outDir * wallCfg.wallJumpImpulse);
                fsm.RequestTransition(PlayerStateMachine.LocoState.JumpRise, "WallJump");
            }
        }
    }
}
```

## `LedgeHangController.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class LedgeHangController : MonoBehaviour
{
    public LedgeConfig ledgeCfg;
    InputAdapter input;
    Sensors2D sensors;
    LocomotionMotor2D motor;
    PlayerStateMachine fsm;

    void Awake()
    {
        input  = GetComponent<InputAdapter>();
        sensors= GetComponent<Sensors2D>();
        motor  = GetComponent<LocomotionMotor2D>();
        fsm    = GetComponent<PlayerStateMachine>();
    }

    public void Tick(float dt)
    {
        if (sensors.isGrounded) return;

        // Grab
        if (sensors.isLedge && fsm.Current != PlayerStateMachine.LocoState.LedgeHang)
        {
            Vector2 snap = sensors.activeLedge ? sensors.activeLedge.WorldHangPoint
                                               : (Vector2)transform.position; // fallback
            int face = sensors.activeLedge ? Mathf.Clamp(sensors.activeLedge.preferFacing, -1, 1) : 0;
            motor.RequestLedgeHang(snap, face);
            fsm.RequestTransition(PlayerStateMachine.LocoState.LedgeHang, "LedgeHang");
            return;
        }

        if (fsm.Current == PlayerStateMachine.LocoState.LedgeHang)
        {
            // Up or toward edge → climb
            int dir = input.MoveX > 0.2f ? 1 : (input.MoveX < -0.2f ? -1 : 0);
            bool goUp = input.MoveY > 0.2f || dir != 0;

            if (goUp)
            {
                Vector2 shift = sensors.activeLedge ? sensors.activeLedge.climbUpShift
                                                    : ledgeCfg.defaultClimbShift;
                if (dir == 0) dir = 1; // default right
                motor.RequestLedgeClimb(dir, shift);
                fsm.RequestTransition(PlayerStateMachine.LocoState.Idle, "LedgeClimb");
            }
            else if (input.DownHeld)
            {
                // drop
                motor.RequestStopClimbRestoreGravity();
                fsm.RequestTransition(PlayerStateMachine.LocoState.JumpFall, "LedgeDrop");
            }
        }
    }
}
```

## `ClimbController.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class ClimbController : MonoBehaviour
{
    public ClimbConfig climbCfg;
    InputAdapter input;
    Sensors2D sensors;
    LocomotionMotor2D motor;
    PlayerStateMachine fsm;

    void Awake()
    {
        input  = GetComponent<InputAdapter>();
        sensors= GetComponent<Sensors2D>();
        motor  = GetComponent<LocomotionMotor2D>();
        fsm    = GetComponent<PlayerStateMachine>();
    }

    public void Tick(float dt)
    {
        if (sensors.onLadder)
        {
            if (Mathf.Abs(input.MoveY) > 0.1f)
            {
                float speed = climbCfg.climbSpeed;
                // ladder volume override (ops)
                var hit = Physics2D.OverlapCircle(transform.position, 0.2f, sensors.ladderMask);
                var vol = hit ? hit.GetComponent<LadderVolume>() : null;
                if (vol && vol.overrideClimbSpeed > 0f) speed = vol.overrideClimbSpeed;

                motor.RequestClimb(input.MoveY * speed);
                fsm.RequestTransition(PlayerStateMachine.LocoState.Climb, "Climb");
            }

            if (input.JumpPressed)
            {
                motor.RequestStopClimbRestoreGravity();
                fsm.RequestTransition(PlayerStateMachine.LocoState.JumpRise, "ClimbJump");
            }
        }
        else if (fsm.Current == PlayerStateMachine.LocoState.Climb)
        {
            motor.RequestStopClimbRestoreGravity();
            fsm.RequestTransition(PlayerStateMachine.LocoState.JumpFall, "ExitClimb");
        }
    }
}
```

## `InteractionController.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class InteractionController : MonoBehaviour
{
    InputAdapter input;
    Sensors2D sensors;

    void Awake()
    {
        input = GetComponent<InputAdapter>();
        sensors = GetComponent<Sensors2D>();
    }

    public void Tick(float dt)
    {
        if (input.InteractPressed && sensors.nearestInteractable)
            sensors.nearestInteractable.Activate();
    }
}
```

## `AbilityController.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class AbilityController : MonoBehaviour
{
    InputAdapter input;
    Sensors2D sensors;
    LocomotionMotor2D motor;
    PlayerStateMachine fsm;

    JumpController jump;
    WallMovement wall;
    LedgeHangController ledge;
    ClimbController climb;
    InteractionController interact;

    void Awake()
    {
        input  = GetComponent<InputAdapter>();
        sensors= GetComponent<Sensors2D>();
        motor  = GetComponent<LocomotionMotor2D>();
        fsm    = GetComponent<PlayerStateMachine>();

        jump  = GetComponent<JumpController>();
        wall  = GetComponent<WallMovement>();
        ledge = GetComponent<LedgeHangController>();
        climb = GetComponent<ClimbController>();
        interact = GetComponent<InteractionController>();
    }

    public void Tick(float dt)
    {
        // Base locomotion intent (yatay)
        motor.RequestHorizontalIntent(input.MoveX);

        // Öncelik: Ledge > Wall > Ladder > Jump > Interact
        ledge?.Tick(dt);
        wall?.Tick(dt);
        climb?.Tick(dt);
        jump?.Tick(dt);
        interact?.Tick(dt);

        // HFSM default çözümü: hang/wall/climb değilse → ground/air
        if (fsm.Current != PlayerStateMachine.LocoState.LedgeHang &&
            fsm.Current != PlayerStateMachine.LocoState.WallSlide &&
            fsm.Current != PlayerStateMachine.LocoState.Climb)
        {
            if (sensors.isGrounded)
                fsm.RequestTransition(Mathf.Abs(input.MoveX) > 0.05f
                    ? PlayerStateMachine.LocoState.Run
                    : PlayerStateMachine.LocoState.Idle, "Grounded");
            else
                fsm.RequestTransition(motor.velocityY > 0f
                    ? PlayerStateMachine.LocoState.JumpRise
                    : PlayerStateMachine.LocoState.JumpFall, "Airborne");
        }
    }
}
```

---

# 🎬 Animasyon & Debug

## `AnimationFacade.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class AnimationFacade : MonoBehaviour
{
    public Animator animator;
    public void SetBool(string n, bool v){ if(animator) animator.SetBool(n,v); }
    public void SetFloat(string n, float v){ if(animator) animator.SetFloat(n,v); }
    public void SetInt(string n, int v){ if(animator) animator.SetInteger(n,v); }
    public void Trigger(string n){ if(animator) animator.SetTrigger(n); }
}
```

## `AnimationStateSync.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class AnimationStateSync : MonoBehaviour
{
    public AnimationFacade anim;
    PlayerStateMachine fsm;
    Sensors2D sensors;
    LocomotionMotor2D motor;

    void Awake()
    {
        fsm = GetComponent<PlayerStateMachine>();
        sensors = GetComponent<Sensors2D>();
        motor = GetComponent<LocomotionMotor2D>();
        if (!anim) anim = GetComponent<AnimationFacade>();

        if (fsm != null)
        {
            fsm.OnLocoChanged += (oldS, newS) =>
            {
                if (newS == PlayerStateMachine.LocoState.JumpRise) anim?.Trigger("Jump");
                if ((newS == PlayerStateMachine.LocoState.Idle || newS == PlayerStateMachine.LocoState.Run) && sensors.justLanded)
                    anim?.Trigger("Land");
            };
            fsm.OnPhaseTriggered += (p) =>
            {
                if (p == PlayerStateMachine.PhaseState.WallJump)  anim?.Trigger("WallJump");
                if (p == PlayerStateMachine.PhaseState.LedgeClimb)anim?.Trigger("LedgeClimb");
            };
        }
    }

    public void LateSync()
    {
        if (anim == null) return;
        anim.SetBool("Grounded", sensors.isGrounded);
        anim.SetBool("WallSliding", fsm.Current == PlayerStateMachine.LocoState.WallSlide);
        anim.SetBool("LedgeHanging", fsm.Current == PlayerStateMachine.LocoState.LedgeHang);
        anim.SetBool("Climbing", fsm.Current == PlayerStateMachine.LocoState.Climb);
        anim.SetFloat("SpeedX", Mathf.Abs(motor.velocityX));
        anim.SetFloat("SpeedY", motor.velocityY);
        anim.SetInt("LocoState", (int)fsm.Current);
    }
}
```

## `DebugOverlay.cs`

```csharp
using UnityEngine;

[DisallowMultipleComponent]
public class DebugOverlay : MonoBehaviour
{
    PlayerStateMachine fsm;
    Sensors2D s;
    LocomotionMotor2D m;

    void Awake()
    {
        fsm = GetComponent<PlayerStateMachine>();
        s = GetComponent<Sensors2D>();
        m = GetComponent<LocomotionMotor2D>();
    }

    void OnGUI()
    {
        int y = 10;
        GUI.Label(new Rect(10, y, 480, 22), $"State: {fsm.Current}"); y += 20;
        GUI.Label(new Rect(10, y, 480, 22), $"Grounded:{s.isGrounded} just:{s.justLanded} head:{s.headBlocked}"); y += 20;
        GUI.Label(new Rect(10, y, 480, 22), $"Wall L/R:{s.wallLeft}/{s.wallRight}  Ledge:{s.isLedge}  Ladder:{s.onLadder}"); y += 20;
        GUI.Label(new Rect(10, y, 480, 22), $"VelX:{m.velocityX:0.00} VelY:{m.velocityY:0.00}"); y += 20;
    }
}
```

---

# 📄 **SETUP: README.md**

```md
# Player Controller (2D Platformer) — Setup Kılavuzu

## 0) Proje Ayarı
- Unity 2021+ (Input System etkin)
- Physics 2D:
  - Queries Start In Colliders: **Off**
  - Default Contact Offset: 0.01–0.05
- Time → Fixed Timestep: **0.02** (50Hz) veya **0.0167** (60Hz)

## 1) Layers ve Collision Matrix
Solid (çarpışan):
- **Ground** — zemin/duvar/tavan
- **OneWay** — PlatformEffector2D ile tek yön
- **MovingPlatform** (opsiyonel)

Trigger (algı):
- **Ladder** — merdiven/halat hacmi
- **Ledge** — kenar tutunma işareti
- **Interactable** — kapı/kol/collectible

> Matrix: `Player` **yalnız** `Ground/OneWay/MovingPlatform` ile çarpışır.
> `Player` **Ladder/Ledge/Interactable** ile **çarpışmaz** (sadece **queries hit triggers** ile okunur).

## 2) Player Prefab
- Components:
  - **Rigidbody2D** (Dynamic, Interpolate), **CapsuleCollider2D** (veya Box)
  - **SpriteRenderer**, **Animator** (opsiyonel)
  - Scripts:
    - `PlayerOrchestrator`, `PlayerStateMachine`
    - `InputAdapter`, `Sensors2D`
    - `LocomotionMotor2D`
    - `AbilityController`, `JumpController`, `WallMovement`, `LedgeHangController`, `ClimbController`
    - `InteractionController`
    - `AnimationFacade`, `AnimationStateSync`
    - `DebugOverlay` (dev)
- Child empties:
  - `Feet` (ayak), `Head` (tavan), `WallL`, `WallR`, `LedgeProbe`, `FollowTarget`

## 3) Sensors2D Wiring
- **solidMask** = `Ground | OneWay | MovingPlatform`
- **oneWayMask** = `OneWay`
- **wallMask** = `Ground`
- **ladderMask** = `Ladder`
- **ledgeMask** = `Ledge`
- **interactMask** = `Interactable`
- `feet/head/wallL/wallR/ledgeProbe` transformlarını bağla.

## 4) ScriptableObject Configs
Project panelden oluştur:
- `MovementConfig`, `JumpConfig`, `WallConfig`, `LedgeConfig`, `ClimbConfig`
- `LocomotionMotor2D` ve ilgili controller script alanlarına ata (Movement/Jump/Wall/Ledge/Climb).

## 5) Input Actions (New Input System)
- **move** (Value/Vector2): WASD + Gamepad Stick
- **jump** (Button): Space / Gamepad South
- **interact** (Button): E / Gamepad West
- `InputAdapter` içindeki `InputActionReference` alanlarına bağla.

## 6) Dünya Kurulumu
- **Ground & Walls (solid):** TilemapCollider2D + (ops.) CompositeCollider2D veya BoxCollider2D. Layer=`Ground`.
- **OneWay (solid):** BoxCollider2D + `PlatformEffector2D(Use One Way=180°)`. Layer=`OneWay`.
- **Ledge (trigger):** Prefab **LedgeMarker** (Layer=`Ledge`, IsTrigger=on) → duvar üst kenarlarına **child** olarak yerleştir.
- **Ladder (trigger):** BoxCollider2D (IsTrigger=on) + (ops.) `LadderVolume`. Layer=`Ladder`.
- **Interactable (trigger):** Küçük BoxCollider2D (IsTrigger=on) + `Interactable`. Layer=`Interactable`.

## 7) Animator (opsiyonel)
Parametreler:
- Bools: `Grounded`, `WallSliding`, `LedgeHanging`, `Climbing`
- Floats: `SpeedX`, `SpeedY`
- Int: `LocoState`
- Triggers: `Jump`, `Land`, `WallJump`, `LedgeClimb`

`AnimationStateSync` bunu otomatik besler.

## 8) Test Planı
- Yürü/Koş → hızlanma/yavaşlama pürüzsüz
- Zıpla → coyote/buffer çalışıyor; tavana çarpınca cut
- OneWay → Down+Jump ile aşağı in
- Duvarda → kayma hızı sınırlı; Jump ile doğru açı/ivme
- Ledge → yakala (trigger), Up/sağ-sol ile çık; Down ile bırak
- Ladder → Up/Down ile tırman; Jump ile ayrıl
- Interact → yanına gel, E ile tetikle
- DebugOverlay → anlık durumu gösterir

## 9) Sık Sorunlar
- **İçinden geçme:** Ledge/Ladder collider’ları **child trigger** olmalı; asıl duvar/zemin **Ground** (solid).
- **Algı yok:** `Sensors2D` layer mask’larını doğru ata; probe/feet/head transform’ları konumlandır.
- **Zıplama zayıf:** `JumpConfig` yüksekliklerini büyüt; `MovementConfig.gravityScale` ile birlikte ayarla.
- **Kayma çok hızlı:** `MovementConfig.wallSlideMaxFall` değerini düşür.
- **FPS düşüyor:** Tek fizik yazarı Motor; raycast/overlap sayısını arttırma; pooling kullan.

## 10) Geliştirme Notu
- Bütün mekanikler “komut/niyet” üretir; **Rigidbody2D’ye yalnız `LocomotionMotor2D` yazar**.
- HFSM geçişleri `PlayerStateMachine` üzerinden; animasyon paramları `AnimationStateSync`’ten gider.
```

---

hazırsan, bir sonraki adımda **küçük bir örnek sahne prefab seti** (LedgeMarker/LadderVolume hazır prefablara) ve **Animator Controller iskeleti** de ekleyebilirim.
